#!/usr/bin/python3

import calendar
import datetime
import getopt
import os
import os.path
import re
import sys
import tempfile
import stat
import math

def usage(retval=0):
    print('''NAME:
        %(prog)s - computes min, max and average simultaneous queries for a specified month

SYNOPSYS:
        %(prog)s
        -h, --help                 display help
        -i, --ignore               ignore first line
        -v, --verbose              display parsed lines
        -s, --separator            specifies the separator between begin & end fields
        -m, --month                specifies the analyzed month; the begin & end fields of the dataset could be modified
                                   to the beginning of the month or the end of the month if necessary
        -p, --period               specifies the output granularity (daily, hourly, [0-9]+m, [0-9]+h)

With no FILE, or when FILE is -, read standard input.
AUTHOR
	Written by Jean-François Giraud.
COPYRIGHT
	Copyright (c) 2016 Jean-François Giraud.
	License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.
    ''' % {'prog': os.path.basename(sys.argv[0])})
    sys.exit(retval)

try:
    opts, args = getopt.getopt(sys.argv[1:], "hvip:s:m:", ["help", "verbose", "ignore", "period=", "separator=", "month="])
except getopt.GetoptError:
    usage(2)


if len(opts) == 0:
    usage()

period=86400 # daily
separator=';'
verbose=False
ignore=False

for o, a in opts:
    if o in ("-h", "--help"):
        usage()
    if o in ("-s", "--separator"):
        separator = a
    if o in ("-v", "--verbose"):
        verbose = True
    if o in ("-i", "--ignore"):
        ignore = True
    if o in ("-p", "--period"):
        pattern = re.compile("([0-9]+)m")
        m = pattern.match(a)
        if m:
            period = 60 * int(m.group(1))
            continue
        if a == 'hourly':
            period = 60 * 60
            continue
        if a == 'daily':
            period = 24 * 60 * 60
            continue
        pattern = re.compile("([0-9]+)h")
        m = pattern.match(a)
        if m:
            period = 60 * 60 * int(m.group(1))
            continue
        raise Exception("invalid period")
    if o in ("-m", "--month"):
        month = a

def create_tmp_and_init(fd_in):
    (fno, new_file) = tempfile.mkstemp()
    with open(fno, 'wt') as fd_out:
        for line in fd_in:
            fd_out.write(line)
    return new_file


def op(filename):
    if filename == '-':
        return True, create_tmp_and_init(sys.stdin)
    else:
        with open(filename, 'rt') as fd_in:
            if stat.S_ISFIFO(os.fstat(fd_in.fileno()).st_mode):
                return True, create_tmp_and_init(fd_in)
            else:
                return False, filename


def as_second(dt):
    return (dt.day-1)*(24*3600) + dt.hour * 3600 + dt.minute * 60 + dt.second


def as_hhmmss(s, day=False):
    if isinstance(s, slice):
        ds = int(s.start / 86400)+1
        de = int(s.stop / 86400)+1
        return "[%.2d@%s->%.2d@%s]" % (ds, as_hhmmss(s.start% 86400), de, as_hhmmss(s.stop% 86400))
    else:
        l = ''
        if day:
            l += "%.2d@" % (int(s/86400)+1)
        l += '%.2d:' % int(s/3600)
        s = s % 3600
        l += '%.2d:' % int(s/60)
        s = s % 60
        l += '%.2d' % s
        return l


if len(args) == 0:
    args = ["-"]

args = [op(x) for x in args]

dt_month_begin = datetime.datetime.strptime("%s-01 00:00:00" % month, "%Y-%m-%d %H:%M:%S")
_, last_day = calendar.monthrange(dt_month_begin.year,dt_month_begin.month)
dt_month_end = datetime.datetime.strptime("%s-%.2d 23:59:59" % (month, last_day), "%Y-%m-%d %H:%M:%S")


counts = [0] * last_day * 86400

for arg in args:
    bool, file_name = arg
    first = True
    with open(file_name, 'rt') as fd:
        for line in fd:
            if ignore and first:
                first = False
                continue
            (line_begin, line_end) = line.strip().split(separator, 2)
            dt_begin = datetime.datetime.strptime(line_begin, "%Y-%m-%d %H:%M:%S")
            dt_end = datetime.datetime.strptime(line_end, "%Y-%m-%d %H:%M:%S")
            if dt_end > dt_month_begin and dt_begin < dt_month_end:
                modified = False
                if dt_begin < dt_month_begin:
                    dt_begin = dt_month_begin
                    modified = True
                if dt_end > dt_month_end:
                    modified = True
                    dt_end = dt_month_end
                s_begin = as_second(dt_begin)
                s_end = as_second(dt_end)+1
                if verbose:
                    print("%s: %s -> %s [%d..%d]" % ("modify" if modified else "accept", dt_begin, dt_end, s_begin, s_end), file=sys.stderr)
                for i in range(s_begin, s_end):
                    counts[i] += 1
            else:
                if verbose:
                    print("ignore: %s -> %s" % (dt_begin, dt_end), file=sys.stderr)


def genrange(delta=86400):
    i = 0
    last_second = last_day * 86400
    while i < math.ceil(last_second / delta):
        start_second = i * delta
        end_second = (i + 1) * delta - 1
        if end_second > last_second:
            end_second = last_second - 1
        yield slice(start_second, end_second)
        i+=1

print("%-26s\tmin\tmax" % "period")
for s in genrange(period):
    minimum = min(counts[s])
    maximum = max(counts[s])
    print("%s\t%d\t%d" % (as_hhmmss(s), minimum, maximum))
min_month = min(counts)
max_month = max(counts)
print("min\t%d\t%s" % (min_month, as_hhmmss(counts.index(min_month), day=True)))
print("max\t%d\t%s" % (max_month, as_hhmmss(counts.index(max_month), day=True)))
